### 构建流

#### 由值构建流

Stream.of
Stream.empty

#### 由数组构建流

可以使用 Arrays.stream 从数组构建流，它可以接收一个原始类型 int 的数组转换成一个 IntStream

#### 由文件生成流

Java 中存在很多用于处理文件等 I/O 的操作的 NIO API(非阻塞 I/O)已更新，以便利用 Strean API.

`java.nio.files` 中的很多静态方法都会返回一个流。例如，一个很有用的方法是 Files.lines,它会返回一个由指定文件中的各行构成的字符串流，

你可以使用 `Files.lines` 得到一个流，其中的每个元素都是给定文件的一行。然后，你可以对 line 调用 split 方法将行拆分成单词。*
*应该注意的是，你应该使用 flatMap 产生一个扁平的单词流，而不是给每一行生成一个单词流。**。

```java
Stream<String> lines=Files.lines(Paths.get("data.txt",Charset.defautCharSet));
        long uniqueSize=lines.flatMap(line->Arrays.stream(line.split(" "))).distict().count();
```

#### 由函数生成流：创建无限流

Stream API 提供了两个静态方法来从函数生成流：`Stream.iterate` 和 `Stream.generate`
。这两个操作可以创建所谓的无限流：不像从固定集合创建的流那样有固定大小的流。由 `iterate` 和 `generate`
产生的流会用给定的函数按需创建值，因此可以无限的创建下去。一般来说，必须使用 `limit(n)` 加以限制。

1. 迭代

```java
Stream.iterate(0,n->n+2).limit(10).forEach(System.out::println);
```

`iterate` 接收一个初始值，还有一个依次产生新值的 Lambda(UnaryOperator(T)类型)，这里我们使用 Lambda (n->n+2),返回的元素是前一个元素加上
2,因此,iterate 方法生成了一个所有正偶数的流。使用 limit 显式的控制流的长度。

> 模式，iterate 需要一个初始值，以及告诉 UnaryOperator 如何生成后续的值。

2. 生成
   和 `iterate` 类似, `generate` 方法也可以生成一个无限流。但 `generate`
   不是依次对每个新生成的值应用函数的，它接受一个 `Supplier<T>` 类型的 Lambda 提供新的值。

```java
Stream.generate(Math::random)
        .limit(5)
        .forEach(System.out::println)
```

这段代码将生成一个流，其中有五个 0 到 1 之间的随机双精度数。

`generate` 还有什么用途。我们的供应源 `Math::random` 是无状态的。但并不是所有的供应源都是无状态的。

> 改变对象状态的流，可能会在并行处理流时导致结果不正确。