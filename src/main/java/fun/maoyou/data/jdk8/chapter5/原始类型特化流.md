Java8引入了三个原始类型特化流接口来解决装箱拆箱的消耗。

1.映射到数值流
将流转换为特化版本的常用方法是mapToInt,mapToDouble,mapToLong.这些方法和
前面的map方法的工作方式一样，只是他们返会一个特化流，而不是Stream<T>.

int calories=menu.stream().mapToInt(Dish::getCalories).sum();
mapToInt会返回一个IntStream,其中的元素都是int类型，避免了自动装箱的消耗

注意，如果流是空的，sum默认返回0.
此外还支持` max` `min ` `average`等操作。

2.转换会对象流
同样，一旦有了数值流，你可能就会想把它转换为非特化流。例如，IntStream上的操作只能产生
原始整数:IntStream的map操作接收的Lambda必须接收int并返回int(一个IntUnaryOperator)
.但是你又想要生成另一类值，如Dish. 为此，你需要Stream接口定义的那些更广义的操作。

要把原始流装换为一般流(每个int都会装箱都会装箱成一个Integer),可以使用boxed方法，如：

IntStream intStream=menu.stream().mapToInt(Dish::getCalories);
Stream<integer> stream=intStream.boxed();

3.默认值OptionalInt
如何区分没有元素的流和最大值真的是0的流呢？

对于三种原始流特化，也分别有一个Optional原始类型特化版本:OptionalInt
,OptionalDouble,OptionalLong.

OptionalInt maxCalories=menu.stream().mapToInt(Dish::getCalories).max();

现在如果没有最大值的话，你就可以显式处理OptionInt去定义一个默认值：
int max=maxCalories.orElse(1);

